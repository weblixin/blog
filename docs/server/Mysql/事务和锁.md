---
title: 事物和锁
---

## Mysql 的事物和锁

_参考文章_

-   <a href="https://www.jianshu.com/p/dffb04ee1a7c">黄靠谱：Mysql 事务和锁</a>
-   <a href="https://www.cnblogs.com/tkzc2013/p/10997057.html">小匡程序员：mysql 事务和锁</a>
-   <a href="https://www.runoob.com/mysql/mysql-transaction.html">菜鸟教程：MySQL 事务</a>
-   <a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1245268672511968">廖雪峰：Repeatable Read</a>

### 锁

#### 共享锁

共享锁又叫做读锁，简称 S 锁。顾名思义，共享锁就是多个事物共享同一把锁，但是只能读不能改。

#### 排它锁

排它锁又叫做写锁，简称 X 锁。顾名思义，排它锁就是不同事物不能使用同一把锁，一个事物获取数据行的排它锁，其他事务就不能获取该行的其他锁(共享锁和排他锁)，只能等第一个事务结束或者排他锁释放出来才能获取。排它锁具有阻塞性，会阻塞其他锁。

-   innoDB 引擎的 update、delete、insert 语句都会给数据加上排它锁
-   select 默认不会添加任何类型的锁。
-   select 添加共享锁 `select * from table1 lock in share mode`
-   select 添加排它锁 `select * from table1 for update`
-   select 添加排它锁后，其他事物不能通过`select * from table1 lock in share mode`和`select * from table1 for update`进行查询，也不能 update、delete、insert，可以通过 `select * from table1`

#### 行锁和表锁

-   表锁
    -   在表级别加锁，是 MySQL 中最基本的锁策略
    -   表锁的开销最小，但并发性能较低
-   行锁
    -   在行级加锁，并发性较高

表锁与行锁没有绝对的性能强弱之分，在应用中可以根据实际场景选择，在锁粒度与数据安全之间寻求一种平衡机制。

InnoDB 的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB 会使用表锁。

#### 乐观锁、悲观锁

-   **悲观锁（Pessimistic Lock）**
    -   悲观锁认为获取锁是有可能失败的，因此要保证获取锁成功在进行业务操作。
    -   通常说的"一锁二查三更新"就是使用的悲观锁。
    -   假如并发高，会屏蔽一切可能违反数据完整性的操作，是串行化级别采取的策略。
    -   必须要有事务控制。
    -   适合高并发时锁竞争激烈的业务场景
-   **乐观锁（Optimistic Lock）**
    -   乐观锁认为获取锁很有可能成功，如果不成功则回滚。
    -   乐观锁在数据库的实现是逻辑层的，不需要数据库提供特殊支持。
    -   通常加版本号或时间戳来上锁。
    -   不发生取锁失败的情况下，数据库开销比悲观锁小，但是一旦失败回滚，开销会比较大，因此适用于取锁失败概率比较小的场景
    -   InnoDB 就是乐观锁 + 版本控制管理，才实现的高并发的 RR 事务级别。

#### 死锁

-   死锁就是两个事务同时占用两组数据并准备更新对方占用的数据，这时两事务均需要等待对方解锁占用的数据
-   死锁一般发生在表和表之间
-   MySQL 自带等待锁超时的时间，默认为 50s，超时自动释放锁
-   如何避免死锁：
    -   尽量别用表锁，为表添加合理的索引
    -   将大事务拆分成多个小事务
    -   在同一事务中，尽可能做到一次锁定所需要的所有资源，降低死锁概率
    -   以固定的顺序访问表和行。即按顺序申请锁
    -   降低隔离级别
    -   优化业务，在并发度上做妥协

### 事务

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如删除用户信息需要将该用户关联的所有信息全部删除。

-   在 MySQL 中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务
-   事务处理可以用来维护数据库的完整性，保证呈批的 SQL 语句要么全部执行，要么全部不执行
-   事务用来管理 insert, update, delete 语句

#### ACID

-   A(原子性)：一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。如果在事务执行中发生错误，会回滚到事务开始之前的状态
-   C(一致性)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏，这就表示写入的数据必须完全符合所有的预设规则，包含精确度、串联型以及后续数据库可以自发完成预定的工作
-   I(隔离性)：数据库允许多个并发事务同事对其数据进行读写和修改，合理性可以防止多个事物并发执行时对于交叉执行而导致的数据不一致。
-   D(持久性)：事物结束后，对数据的修改是永久的，即便系统故障也不会丢失

```
在 MySQL 命令行的默认设置中，事物都是自动提交的
也就是执行 sql 语句后就会立马执行 commit 操作
因此要显式地开启一个事物，必须使用命令 begin/start transaction 或者执行命令 set autocommit=0
```

#### 事物隔离级别

-   Read uncommitted(读未提交)
    -   在这个级别，事务中的修改即使没有提交对其他事务也都是课件的
    -   事务可读取未提交的数据，称之为脏读(Dirty Read)
-   read committed(读提交)
    -   在这个级别，只能读取事务 commit 以后的数据
    -   由于两次执行同样的查询，可能会得到不一样的结果，所以又叫做不可重读读(nonrepeatable read)
-   repeatable read(可复读型)

    -   在这个级别中，解决了读未提交中的脏读的问题，保证了同一事务多次执行通产的查询，结果是一致的
    -   可能会导致幻读(Phantom Read)

        > 幻读: 在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

    -   MySQL 的默认事务隔离级别

-   Serializable(串行化)
    -   级别最高的事务隔离
    -   它会强制事务串行执行，避免了幻读、脏读，但是并发性不太好

#### 事务控制语句

-   `BEGIN/START TRANSACTION` 显示的开启一个事物
-   `COMMIT` 或 `COMMIT WORK` 提交事务，并且使已对数据库进行的修改编程永久性的
-   `ROLLBACK` 或 `ROLLBACK WORK` 回滚事务，并且撤销正在进行的所有未提交的修改
-   `SAVEPOINT identifier`，`SAVEPOINT` 允许在事务中创建一个保存点，一个事务可以有多个保存点
-   `RELEASE SAVEPOINT identifier` 删除一个事务的保存点，当没有保存点是，会抛出异常
-   `ROOLBACK TO identifier` 把事务回滚到保存点
-   `SET TRANSACTION` 用老设置事务的隔离级别

#### MySQL 事务处理的方法

1. 用 `BEGIN`、`ROLLBACK`、`COMMIT` 实现
    - `BEGIN` 开始一个事务
    - `ROLLBACK` 事务回滚
    - `COMMIT` 事务确认/提交
2. 用 `SET` 改变 MySQL 的自动提交模式
    - `SET AUTOCOMMIT=0` 禁止自动提交
    - `SET AUTOCOMMIT=1` 开启自动提交
