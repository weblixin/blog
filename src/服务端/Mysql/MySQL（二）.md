## MySql 的基础架构

_参考文章_

-   <a href="https://mp.weixin.qq.com/s?__biz=MzUxNzk1MjQ0Ng==&mid=100000140&idx=1&sn=bd68625780af680bfe465cea78fb83c4&scene=19#wechat_redirect">koala: MySql 基础架构(sql 查询语句在 MySql 内部具体是怎么执行的?)</a>

### 引题

> 一条 sql 查询语句在 mysql 数据库中具体是怎么执行的？

### 架构示意图

![mysql 基础架构](https://user-images.githubusercontent.com/32237197/77192948-5e145780-6b18-11ea-88d2-f6f2199e2a8a.jpg)  
从图中我们可以看出 MySQL 可以分为 Server 层和存储引擎层两部分。

### Server 层

#### 连接器

运行 sql 语句的第一步就是连接数据库。连接器就是负责与客户端建立连接、获取权限、维持和管理连接。连接器在 TCP 握手后，开始认证身份。

> 开始连接时，验证用户名和密码，如果验证不通过，服务器会收到 `Access denied for user` 的错误返回。

> 如果验证通过，连接器会到权限表中查出拥有的权限。  
> 此次连接查到的权限在这次连接失效前一直有效，不会因为权限的更改而受到影响。

> 连接完成后，如果一直没有对数据库进行操作，则本次连接处于空闲状态。  
> `show processlist` 查看所有连接, `command` 表示连接状态, `sleep` 表示空闲

> 客户端如果太长时间没有请求数据库，连接器会自动断开，默认为 8 小时,可以通过 `wait_timeout` 自定义。

> 连接断开后，客户端再次发送请求，会受到错误提醒: `Lost connection to MySQL server during query`， 需要重新连接服务器。

> **\***长连接**\* ：** 数据库连接成功后，客户端持续有请求，使用同一个连接。  
> **_短连接 ：_** 一次连接只是执行几次 sql 语句就断开，下次执行再重新创建一个。

> 由于建立连接过程比较复杂，所以在使用中要尽量减少连接次数，尽量使用长连接。

> 全部使用长连接，由于 mysql 在执行过程中临时使用的内存是保存在连接对象中的，只有在链接断开的时候才会释放，因此 mysql 占用内存会涨的特别快。所以长连接累积下来，会导致内存占用太大，被系统强行杀掉(OOM)，mysql 异常重启。  
> 解决方案：
>
> -   定期断开长连接。使用一段时间后，或者在执行了一个占用内存大的查询后，断开连接，之后查询时再重连。
> -   mysql 5.7 或 以后的版本，可以执行 `mysql_reset_connection` 来初始化连接资源。不需要重新连接，会将连接恢复到刚创建完的状态。

#### 查询缓存

连接数据库后，需要先查询缓存。  
如果之前执行过这条查询语句，查询结果可能会以 key-value 的形式保存在内存中。key 是查询的语句， value 是查询到的数据。查询缓存会直接把 value 返回给客户端。  
如果查询语句不在查询缓存中，会继续往下执行，获取到的新的查询结果会被存入到查询缓存中。

-   查询缓存适用于静态表
-   将 `query_cache_type` 设置为 `DEMAND`, 这样就不适用查询缓存了
-   可以使用 `SQL_CACHE` 指定某一条语句是否使用查询缓存 `select SQL_CACHE * from table`
-   mysql 8.0 以后删除了查询缓存模块

#### 分析器

-   词法分析 mysql 识别 sql 语句每个字符串代表的意思
-   语法分析 分析 sql 语句是否符合语法规则，语法有误则返回`Tou have an error in your SQL syntax`

#### 优化器

-   当表中有多个索引的时候，优化器会决定 sql 语句使用哪个索引
-   当查询语句有多表关联时，决定各个表的连接顺序

    ```javascript
    mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
    ```

    -   先查 t1，再查 t2
    -   先查 t2，再查 t1
    -   查询结果相同，执行效率不同

#### 执行器

执行 sql 语句时，先判断对这个表有没有查询的权限，没有权限会返回没有权限的错误。如果有权限就继续执行，使用存储引擎，

#### 存储引擎

-   ID 字段没有索引：
    -   调用 InnoDB 引擎接口取这个表的第一行，判断 ID 是不是 1，如果不是跳过，如果是则将这行存在结果集中
    -   调用引擎接口取下一行，重复相同的判断逻辑，知道最后
    -   将所有的结果组成结果集返回给客户端
-   ID 字段有索引：
    -   取满足条件的第一行，直到最后一行保存为结果集，返回给客户端
